<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Signature Generator v11</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        :root {
            --bg-primary: #0d1017;
            --bg-secondary: #1a1f2e;
            --bg-card: #252b3d;
            --accent: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --text-primary: #e8eaed;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border: #374151;
            --border-focus: #00d4ff;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-card);
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 0 1px var(--border);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: var(--gradient);
            opacity: 0.6;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            background: var(--gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            letter-spacing: -0.5px;
            position: relative;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 40px;
            align-items: start;
        }
        
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 24px;
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group label {
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-group input, .form-group select {
            padding: 12px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }
        
        .form-group input::placeholder {
            color: var(--text-muted);
        }
        
        .energies-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .energy-input {
            text-align: center;
            font-weight: 600;
        }
        
        .energy-input input {
            text-align: center;
            font-weight: 600;
            color: var(--accent) !important;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
            height: 20px;
            margin: 8px 0;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: var(--bg-primary);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--border);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--bg-card);
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.3);
            margin-top: -8px;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-track {
            background: var(--bg-primary);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--border);
        }
        
        input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--bg-card);
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.3);
            cursor: pointer;
            border: none;
        }
        
        .form-group label span {
            color: var(--accent);
            font-weight: 600;
            font-family: monospace;
            background: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid var(--border);
            float: right;
        }
        
        .button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: var(--accent);
            color: var(--bg-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .button:hover::before {
            left: 100%;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--accent-glow);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .button-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .button-secondary:hover {
            background: var(--border);
            border-color: var(--text-secondary);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .button-success {
            background: var(--success);
            color: white;
        }
        
        .button-success:hover {
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }
        
        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 20px;
        }
        
        .section-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-header::before {
            content: '';
            width: 3px;
            height: 20px;
            background: var(--accent);
            border-radius: 2px;
        }
        
        .visualization-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        
        #svgContainer {
            width: 512px;
            height: 512px;
            border-radius: 12px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 24px;
            position: relative;
            overflow: hidden;
        }
        
        #svgContainer svg {
            width: 100%;
            height: 100%;
        }

        .placeholder-text {
            text-align: center;
            color: var(--text-muted);
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .test-section, .validator-section {
            margin-top: 32px;
            padding: 24px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        
        .test-section h3, .validator-section h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .file-input {
            margin: 16px 0;
        }
        
        .file-input input[type="file"] {
            display: none;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: var(--bg-primary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .file-input-label:hover {
            background: var(--border);
            border-color: var(--accent);
        }
        
        #testResults, #validationResults {
            margin-top: 16px;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: 'JetBrains Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            color: var(--text-primary);
            line-height: 1.4;
        }
        
        .status-info {
            margin-top: 12px;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            width: 100%;
            text-align: center;
        }
        
        .status-success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .status-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        #calligraphicParams {
            display: none;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            .container { padding: 24px; }
            h1 { font-size: 2.2rem; }
            .export-buttons { grid-template-columns: 1fr; gap: 12px; }
            #svgContainer { width: 100%; max-width: 480px; height: auto; aspect-ratio: 1 / 1; }
        }
        
        @media (max-width: 768px) {
            body { padding: 16px; }
            .container { padding: 20px; }
            h1 { font-size: 1.8rem; }
            .energies-grid { grid-template-columns: repeat(2, 1fr); gap: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Генератор Энергоподписей v11</h1>
        
        <div class="main-content">
            <div class="input-section">
                <div class="form-group">
                    <label for="huid">HUID (Уникальный идентификатор):</label>
                    <input type="text" id="huid" placeholder="Введите HUID" value="H-DEMO-001">
                </div>
                
                <div class="form-group">
                    <label for="timestamp">Timestamp (UTC ms):</label>
                    <input type="number" id="timestamp" placeholder="Временная метка">
                </div>
                
                <div class="form-group">
                    <label>Энергии [P, I, E, C] (0-5):</label>
                    <div class="energies-grid">
                        <div class="energy-input"><input type="number" id="energy1" placeholder="P" value="2" min="0" max="5" step="1"></div>
                        <div class="energy-input"><input type="number" id="energy2" placeholder="I" value="3" min="0" max="5" step="1"></div>
                        <div class="energy-input"><input type="number" id="energy3" placeholder="E" value="2" min="0" max="5" step="1"></div>
                        <div class="energy-input"><input type="number" id="energy4" placeholder="C" value="4" min="0" max="5" step="1"></div>
                    </div>
                </div>
                
                <div class="section-header">Визуальные параметры</div>
                
                <div class="form-group">
                    <label for="style">Стиль:</label>
                    <select id="style">
                        <option value="organica">Organica</option>
                        <option value="geometric">Geometric</option>
                        <option value="calligraphic">Calligraphic</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="context">Контекст:</label>
                    <input type="text" id="context" placeholder="Контекстная информация" value="demo_v11">
                </div>
                
                <div class="section-header">Тонкие настройки</div>
                
                <div class="form-group">
                    <label>Масштаб линий: <span id="lineScaleValue">1.0</span></label>
                    <input type="range" id="lineScale" min="0.5" max="3" step="0.1" value="1.0">
                </div>
                
                <div class="form-group">
                    <label>Интенсивность волн: <span id="wavesIntensityValue">1.0</span></label>
                    <input type="range" id="wavesIntensity" min="0.2" max="2" step="0.1" value="1.0">
                </div>
                
                <div class="form-group">
                    <label>Плотность точек: <span id="pointsDensityValue">1.0</span></label>
                    <input type="range" id="pointsDensity" min="0.3" max="2" step="0.1" value="1.0">
                </div>
                
                <div class="form-group">
                    <label>Уровень лучей (для Geometric): <span id="raysLevelValue">50</span></label>
                    <input type="range" id="raysLevel" min="0" max="100" step="1" value="50">
                </div>

                <div id="calligraphicParams">
                    <div class="form-group">
                        <label>Множитель пера (Calligraphic): <span id="penMulValue">1.4</span></label>
                        <input type="range" id="penMul" min="0.5" max="3" step="0.1" value="1.4">
                    </div>
                     <div class="form-group">
                        <label>Сглаживание (Calligraphic): <span id="penSmoothValue">2</span></label>
                        <input type="range" id="penSmooth" min="0" max="3" step="1" value="2">
                    </div>
                </div>
                
                <button class="button" id="generateButton">Генерировать Подпись</button>
                
                <div class="export-buttons">
                    <button class="button button-secondary" id="exportPNGButton">PNG</button>
                    <button class="button button-secondary" id="exportSVGButton">SVG</button>
                    <button class="button button-success" id="exportJSONButton">JSON</button>
                </div>
            </div>
            
            <div class="visualization-section">
                <div class="section-header">Предварительный просмотр</div>
                <div id="svgContainer">
                    <div class="placeholder-text">
                        Генерируйте энергоподпись
                    </div>
                </div>
                
                <div id="statusInfo" class="status-info" style="display: none;"></div>
                
                <div id="metadataContainer" style="display: none; width: 100%; margin-top: 16px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; font-family: monospace; font-size: 0.8rem;">
                        <div>
                            <div style="color: var(--text-secondary); margin-bottom: 4px;">Seed Hash:</div>
                            <div id="seedDisplay" style="color: var(--accent); word-break: break-all;"></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); margin-bottom: 4px;">Content Hash:</div>
                            <div id="hashDisplay" style="color: var(--success); word-break: break-all;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <h3>Тестирование системы</h3>
            <p style="color: var(--text-secondary); margin-bottom: 16px;">Проверка детерминированности, уникальности и рендеринга стилей:</p>
             <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                <div style="background: var(--bg-primary); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                    <strong style="color: var(--accent);">T1:</strong> Детерминизм<br>
                    <small style="color: var(--text-muted);">3 одинаковых входа → 3 одинаковых SVG-хэша</small>
                </div>
                <div style="background: var(--bg-primary); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                    <strong style="color: var(--success);">T2:</strong> Уникальность<br>
                    <small style="color: var(--text-muted);">200 разных HUID → 200 уникальных контент-хэшей</small>
                </div>
                <div style="background: var(--bg-primary); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                    <strong style="color: var(--warning);">T3:</strong> Стили<br>
                    <small style="color: var(--text-muted);">Разные стили → разные SVG-хэши</small>
                </div>
            </div>
            <button class="button button-secondary" id="runTestsButton">Запустить все тесты</button>
            <div id="testResults">...Ожидание запуска тестов...</div>
        </div>
        
        <div class="validator-section">
            <h3>Валидатор метаданных</h3>
            <p style="color: var(--text-secondary); margin-bottom: 16px;">Проверка целостности экспортированных JSON файлов:</p>
            <div class="file-input">
                <label for="jsonFile" class="file-input-label">Выберите JSON файл</label>
                <input type="file" id="jsonFile" accept=".json">
            </div>
            <button class="button button-success" id="validateJSONButton">Валидировать файл</button>
            <div id="validationResults">...Ожидание файла для валидации...</div>
        </div>
    </div>

    <script>
        let currentSignatureData = null;
        let jsonFileContent = null;
    
        const $ = (id) => document.getElementById(id);

        const palettes = {
            gold: { main: '#d4af37', pale: 'rgba(185, 205, 191, 0.6)', bg: '#0d1017' },
            fire: { main: '#ff6e40', pale: 'rgba(255, 220, 180, 0.6)', bg: '#1f0a08' },
            water: { main: '#40c4ff', pale: 'rgba(200, 230, 255, 0.6)', bg: '#081221' },
            neon: { main: '#00e5ff', pale: 'rgba(224, 247, 250, 0.6)', bg: '#0d0d0d' }
        };

        const _enc = (typeof TextEncoder !== 'undefined') ? new TextEncoder() : { encode: s => new Uint8Array([...unescape(encodeURIComponent(s))].map(c => c.charCodeAt(0))) };
        const _hex = buf => [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, '0')).join('');
        async function sha256Hex(s) {
            try {
                if (crypto?.subtle?.digest) return _hex(await crypto.subtle.digest('SHA-256', _enc.encode(s)));
            } catch (_) {}
            let h1 = 0x811c9dc5 >>> 0, h2 = 0x01000193 >>> 0;
            for (let i = 0; i < s.length; i++) {
                const ch = s.charCodeAt(i);
                h1 ^= ch;
                h1 = Math.imul(h1, 0x01000193) >>> 0;
                h2 ^= (h1 >>> 13);
                h2 = Math.imul(h2, 0x85ebca6b) >>> 0;
            }
            return (h1.toString(16).padStart(8, '0') + h2.toString(16).padStart(8, '0')).repeat(4);
        }

        const V11 = 'v11';
        function makeSeedString({ huid, ts, energies, context, style }) {
            if (!new RegExp('^[A-Za-z0-9._-]{3,64}$').test(huid || '')) throw new Error('HUID_INVALID');
            const eCSV = Array.isArray(energies) ? energies.join(',') : String(energies);
            return `${huid}|${ts}|${eCSV}|${context}|${style}|${V11}`;
        }
        const _u32 = (h, o) => parseInt(h.slice(o, o + 8), 16) >>> 0;
        const _sfc32 = (a, b, c, d) => () => { a |= 0; b |= 0; c |= 0; d |= 0; let t = (a + b | 0) + d | 0; d = d + 1 | 0; a = b ^ (b >>> 9); b = c + (c << 3) | 0; c = (c << 21) | (c >>> 11); c = c + t | 0; return (t >>> 0) / 4294967296 };
        function prngFromSeedHex(seedHex) { return _sfc32(_u32(seedHex, 0), _u32(seedHex, 8), _u32(seedHex, 16), _u32(seedHex, 24)); }

        async function buildSeed(params) {
            const seedString = makeSeedString(params);
            const seedHex = await sha256Hex(seedString);
            const rnd = prngFromSeedHex(seedHex);
            return { seedString, seedHex, rnd };
        }

        const TAU = Math.PI * 2;
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const polar = (cx, cy, r, ang) => ({ x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) });
        function chaikin(points, iters = 1) {
            if (iters === 0) return points;
            let pts = points.slice();
            for (let k = 0; k < iters; k++) {
                const out = [];
                if (pts.length < 2) return pts;
                for (let i = 0; i < pts.length - 1; i++) {
                    const p = pts[i], q = pts[i + 1];
                    out.push({ x: lerp(p.x, q.x, 0.25), y: lerp(p.y, q.y, 0.25) });
                    out.push({ x: lerp(p.x, q.x, 0.75), y: lerp(p.y, q.y, 0.75) });
                }
                pts = out;
            }
            return pts;
        }
        function catmullRomPath(pts, closed = true) {
            const P = pts.slice();
            if (P.length < 2) return '';
            if (closed) { P.unshift(pts[pts.length - 1]); P.push(pts[0], pts[1]); }
            const q = n => Number(n.toFixed(2));
            let d = `M ${q(P[closed ? 1 : 0].x)} ${q(P[closed ? 1 : 0].y)}`;
            for (let i = 1; i < P.length - 2; i++) {
                const p0 = P[i - 1], p1 = P[i], p2 = P[i + 1], p3 = P[i + 2];
                const cp1 = { x: q(p1.x + (p2.x - p0.x) / 6), y: q(p1.y + (p2.y - p0.y) / 6) };
                const cp2 = { x: q(p2.x - (p3.x - p1.x) / 6), y: q(p2.y - (p3.y - p1.y) / 6) };
                d += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${q(p2.x)} ${q(p2.y)}`;
            }
            return d + (closed ? ' Z' : '');
        }

        function genOrganica({ cx = 256, cy = 256, rnd, energies: [P, I, E, C], lineScale = 1.0 }) {
            const R0 = 110 + I * 4;
            const a1 = 0.15 + E * 0.03;
            const a2 = 0.10 + C * 0.02;
            const k1 = 3 + Math.floor(rnd() * 3 + P * 0.2);
            const k2 = 5 + Math.floor(rnd() * 4 + P * 0.1);
            const p1 = rnd() * TAU, p2 = rnd() * TAU;
            const M = 96 + P * 8;
            const pts = [];
            for (let i = 0; i < M; i++) {
                const th = i / M * TAU;
                const r = R0 * (1 + a1 * Math.sin(k1 * th + p1) + a2 * Math.sin(k2 * th + p2));
                pts.push(polar(cx, cy, r, th));
            }
            const smooth = catmullRomPath(pts, true);
            const coreR = 28 + ((P + I + E + C) / 4) * 3 * lineScale;
            return { type: 'organica', path: smooth, core: { cx, cy, r: Number(coreR.toFixed(2)) } };
        }

        function genGeometric({ cx = 256, cy = 256, rnd, energies: [P, I, E, C], raysLevel = 0, lineScale = 1.0 }) {
            const n = clamp(2.0 - P * 0.2 + rnd() * 0.5, 0.6, 3.0);
            const R = 120 + I * 3;
            const k = 3 + Math.floor(C * 1.2 + rnd() * 3);
            const mA = 0.12 + E * 0.03;
            const M = 2 * k * 24;
            const rot = rnd() * TAU;
            const pts = [];
            for (let i = 0; i < M; i++) {
                const th = i / M * TAU + rot;
                const base = 1 / Math.sqrt(Math.pow(Math.abs(Math.cos(th)), 2 / n) + Math.pow(Math.abs(Math.sin(th)), 2 / n));
                const mod = 1 + mA * Math.cos(k * th);
                const r = R * base * mod;
                pts.push(polar(cx, cy, r, th));
            }
            let rays = null;
            if (raysLevel > 0) {
                const count = Math.round((24 + 6 * C) * (clamp(raysLevel, 0, 100) / 100));
                const r1 = 40 + I * 6, r2 = 200 + P * 10;
                const step = TAU / count;
                const items = [];
                for (let i = 0; i < count; i++) {
                    const a = i * step + rot * 0.5;
                    items.push({ x1: cx + Math.cos(a) * r1, y1: cy + Math.sin(a) * r1, x2: cx + Math.cos(a) * r2, y2: cy + Math.sin(a) * r2 });
                }
                rays = { count, r1, r2, items };
            }
            const coreR = 28 + ((P + I + E + C) / 4) * 3 * lineScale;
            return { type: 'geometric', path: catmullRomPath(pts, true), rays, core: { cx, cy, r: Number(coreR.toFixed(2)) } };
        }

        function genCalligraphic({ cx = 256, cy = 256, rnd, energies: [P, I, E, C], penMul = 1.4, penSmooth = 2, lineScale = 1.0 }) {
            const R0 = 105 + I * 5;
            const a1 = 0.14 + E * 0.02, a2 = 0.10 + C * 0.02;
            const k1 = 2 + Math.floor(rnd() * 3), k2 = 5 + Math.floor(rnd() * 3);
            const p1 = rnd() * TAU, p2 = rnd() * TAU;
            const N = 80 + P * 10;
            const ctr = [];
            for (let i = 0; i < N; i++) {
                const t = i / (N - 1);
                const th = t * TAU;
                const r = R0 * (1 + a1 * Math.sin(k1 * th + p1) + a2 * Math.sin(k2 * th + p2));
                ctr.push(polar(cx, cy, r, th));
            }
            const base = (2.0 + E * 0.8) * penMul * lineScale;
            const varA = 0.6 + C * 0.25;
            const varK = 3 + Math.floor(rnd() * 4);
            const left = [], right = [];
            for (let i = 0; i < ctr.length; i++) {
                const p = ctr[i];
                const q = ctr[(i + 1) % ctr.length];
                const dx = (q.x - p.x), dy = (q.y - p.y);
                const len = Math.max(1e-6, Math.hypot(dx, dy));
                const nx = -dy / len, ny = dx / len;
                const t = i / (ctr.length - 1);
                const w = base * (1 + varA * Math.sin(varK * t * TAU));
                left.push({ x: p.x + nx * w, y: p.y + ny * w });
                right.push({ x: p.x - nx * w, y: p.y - ny * w });
            }
            let ribbon = left.concat(right.reverse());
            if (penSmooth > 0) ribbon = chaikin(ribbon, clamp(penSmooth | 0, 0, 3));
            const q = n => Number(n.toFixed(2));
            let d = `M ${q(ribbon[0].x)} ${q(ribbon[0].y)}`;
            for (let i = 1; i < ribbon.length; i++) { d += ` L ${q(ribbon[i].x)} ${q(ribbon[i].y)}`; }
            d += ' Z';
            const coreR = 26 + ((P + I + E + C) / 4) * 2.5;
            return { type: 'calligraphic', path: d, core: { cx, cy, r: Number(coreR.toFixed(2)) } };
        }
        
        function generateBackgroundLayer(rnd, palette, { size, density }) {
            const pointsCount = 150 * density;
            let svg = `<rect width="${size}" height="${size}" fill="${palette.bg}" />`;
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('opacity', '0.4');

            for (let i = 0; i < pointsCount; i++) {
                const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                c.setAttribute('cx', (rnd() * size).toFixed(2));
                c.setAttribute('cy', (rnd() * size).toFixed(2));
                c.setAttribute('r', (rnd() * 1.5 + 0.4).toFixed(2));
                c.setAttribute('fill', palette.pale);
                c.setAttribute('fill-opacity', (rnd() * 0.5 + 0.2).toFixed(2));
                g.appendChild(c);
            }
            return svg + g.outerHTML;
        }

        function generateWavesLayer(rnd, palette, { size, intensity }) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('fill', 'none');
            g.setAttribute('stroke', palette.pale);
            g.setAttribute('stroke-opacity', (0.2 * intensity).toFixed(2));

            const rings = 3 + Math.floor(rnd() * 5 * intensity);
            for (let i = 0; i < rings; i++) {
                const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                c.setAttribute('cx', size / 2);
                c.setAttribute('cy', size / 2);
                c.setAttribute('r', (size * 0.1 + i * size * 0.08 + rnd() * 10).toFixed(2));
                c.setAttribute('stroke-width', (rnd() * 1.2 + 0.5).toFixed(2));
                g.appendChild(c);
            }
            return g.outerHTML;
        }

        function generateSpiralLayer(rnd, palette, { size, intensity }) {
             const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('fill', 'none');
            g.setAttribute('stroke', palette.pale);
            
            const spiralTurns = (1 + rnd() * 4) * intensity;
            if (spiralTurns < 0.5) return '';

            let dSp = '';
            const steps = 200;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const ang = t * TAU * spiralTurns;
                const rad = size * 0.05 + t * size * 0.4;
                const x = (size / 2 + Math.cos(ang) * rad).toFixed(2);
                const y = (size / 2 + Math.sin(ang) * rad).toFixed(2);
                dSp += (i ? ' L' : 'M') + x + ',' + y;
            }
            const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            p.setAttribute('d', dSp);
            p.setAttribute('stroke-width', (rnd() * 1.0 + 0.6).toFixed(2));
            p.setAttribute('stroke-opacity', (0.3 * intensity).toFixed(2));
            g.appendChild(p);
            return g.outerHTML;
        }

        function buildSvgContent({ background, waves, spiral, emblem, size, palette, lineScale }) {
            const mainPathFill = emblem.type === 'calligraphic' ? palette.main : 'none';
            const mainPathStroke = palette.main;

            let raysSvg = '';
            if (emblem.rays && emblem.rays.items) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('stroke', palette.pale);
                g.setAttribute('stroke-opacity', '0.35');
                emblem.rays.items.forEach(r => {
                    const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    l.setAttribute('x1', r.x1.toFixed(2)); l.setAttribute('y1', r.y1.toFixed(2));
                    l.setAttribute('x2', r.x2.toFixed(2)); l.setAttribute('y2', r.y2.toFixed(2));
                    l.setAttribute('stroke-width', (0.6 * lineScale).toFixed(2));
                    g.appendChild(l);
                });
                raysSvg = g.outerHTML;
            }

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                    </defs>
                    ${background}
                    ${waves}
                    ${spiral}
                    ${raysSvg}
                    <g filter="url(#softGlow)">
                        <path d="${emblem.path}" fill="${mainPathFill}" stroke="${mainPathStroke}" stroke-width="${(2.2 * lineScale).toFixed(2)}" stroke-linecap="round" stroke-linejoin="round"/>
                        ${emblem.core ? `<circle cx="${emblem.core.cx}" cy="${emblem.core.cy}" r="${emblem.core.r}" fill="none" stroke="${mainPathStroke}" stroke-width="${(1.2 * lineScale).toFixed(2)}" />` : ''}
                    </g>
                </svg>`;
        }
        
        async function generateSignature(inputs) {
            const params = { ...inputs };
            const { seedHex, rnd } = await buildSeed(params);
            
            const size = 512;
            const palette = palettes.gold;

            const backgroundLayer = generateBackgroundLayer(rnd, palette, { size, density: params.pointsDensity });
            const wavesLayer = generateWavesLayer(rnd, palette, { size, intensity: params.wavesIntensity });
            const spiralLayer = generateSpiralLayer(rnd, palette, { size, intensity: params.wavesIntensity });

            let emblemData;
            const emblemParams = { rnd, energies: params.energies, lineScale: params.lineScale, cx: size/2, cy: size/2 };
            if (params.style === 'organica') {
                emblemData = genOrganica(emblemParams);
            } else if (params.style === 'geometric') {
                emblemData = genGeometric({ ...emblemParams, raysLevel: params.raysLevel });
            } else if (params.style === 'calligraphic') {
                emblemData = genCalligraphic({ ...emblemParams, penMul: params.penMul, penSmooth: params.penSmooth });
            }

            const svgContent = buildSvgContent({ background: backgroundLayer, waves: wavesLayer, spiral: spiralLayer, emblem: emblemData, size, palette, lineScale: params.lineScale });

            const metadata = { generatedAt: new Date().toISOString(), version: "v11" };
            const dataToHash = {
                seedHex,
                inputs,
                layers: { emblem: { type: emblemData.type } },
                metadata
            };
            if(emblemData.type === 'geometric' && emblemData.rays) {
                dataToHash.layers.emblem.rays = { count: emblemData.rays.count };
            }
            
            const canonicalData = canonicalJSON(dataToHash);
            const hashHex = await sha256Hex(JSON.stringify(canonicalData));

            return { ...dataToHash, hashHex, svgContent };
        }

        function canonicalJSON(obj) {
            if (typeof obj !== 'object' || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(canonicalJSON);
            return Object.keys(obj).sort().reduce((acc, key) => {
                acc[key] = canonicalJSON(obj[key]);
                return acc;
            }, {});
        }

        async function handleGenerateClick() {
            showStatus('Генерация...', 'info');
            try {
                const inputs = {
                    huid: $('huid').value.trim(),
                    ts: parseInt($('timestamp').value) || Date.now(),
                    energies: [
                        clamp(parseInt($('energy1').value) || 0, 0, 5),
                        clamp(parseInt($('energy2').value) || 0, 0, 5),
                        clamp(parseInt($('energy3').value) || 0, 0, 5),
                        clamp(parseInt($('energy4').value) || 0, 0, 5),
                    ],
                    context: $('context').value.trim(),
                    style: $('style').value,
                    lineScale: parseFloat($('lineScale').value),
                    wavesIntensity: parseFloat($('wavesIntensity').value),
                    pointsDensity: parseFloat($('pointsDensity').value),
                    raysLevel: parseInt($('raysLevel').value),
                    penMul: parseFloat($('penMul').value),
                    penSmooth: parseInt($('penSmooth').value),
                };

                if (!inputs.huid) {
                    showStatus('Пожалуйста, введите HUID.', 'error');
                    return;
                }
                
                const startTime = performance.now();
                currentSignatureData = await generateSignature(inputs);
                const generationTime = Math.round(performance.now() - startTime);
                
                currentSignatureData.metadata.generationTime = generationTime;

                $('svgContainer').innerHTML = currentSignatureData.svgContent;
                $('metadataContainer').style.display = 'block';
                $('seedDisplay').textContent = currentSignatureData.seedHex.substring(0, 32) + '...';
                $('hashDisplay').textContent = currentSignatureData.hashHex.substring(0, 32) + '...';

                showStatus(`Генерация завершена за ${generationTime}мс`, 'success');

            } catch (error) {
                console.error("Ошибка генерации:", error);
                showStatus(`Ошибка генерации: ${error.message}`, 'error');
            }
        }

        function exportFile(filename, content, type) {
            if (!currentSignatureData) {
                showStatus('Сначала сгенерируйте подпись', 'error'); return;
            }
            const blob = new Blob([content], { type });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        function exportPNG() {
            if (!currentSignatureData) {
                showStatus('Сначала сгенерируйте подпись', 'error'); return;
            }
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const img = new Image();
            const svgBlob = new Blob([currentSignatureData.svgContent], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            img.onload = () => {
                ctx.drawImage(img, 0, 0, size, size);
                URL.revokeObjectURL(url);
                canvas.toBlob((blob) => {
                    exportFile(`signature-${currentSignatureData.inputs.huid}.png`, blob, 'image/png');
                    showStatus('PNG экспортирован', 'success');
                });
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                showStatus('Ошибка при рендеринге PNG', 'error');
            };
            img.src = url;
        }

        async function runTests() {
            const resultsDiv = $('testResults');
            resultsDiv.textContent = 'Выполнение тестов...\n\n';
            showStatus('Запуск тестов...', 'info');

            let allPass = true;
            let resultsText = 'РЕЗУЛЬТАТЫ КОМПЛЕКСНОГО ТЕСТИРОВАНИЯ v11\n' + '='.repeat(40) + '\n\n';

            resultsText += 'T1: ДЕТЕРМИНИЗМ (3 одинаковых SVG)\n';
            const t1_inputs = { huid: 'TEST-DETERMINISM-V11', ts: 1723712345678, energies: [1, 2, 3, 4], context: 'test', style: 'organica', lineScale: 1, wavesIntensity: 1, pointsDensity: 1, raysLevel: 50, penMul: 1.4, penSmooth: 2 };
            const t1_hashes = [];
            let t1_pass = true;
            try {
                for (let i = 0; i < 3; i++) {
                    const sig = await generateSignature(t1_inputs);
                    const svgHash = await sha256Hex(sig.svgContent);
                    t1_hashes.push(svgHash);
                }
                if (new Set(t1_hashes).size !== 1) t1_pass = false;
                resultsText += `   Результат: ${t1_pass ? '✅ PASS' : '❌ FAIL'}\n`;
                resultsText += `   Hash: ${t1_hashes[0].substring(0, 32)}...\n\n`;
            } catch (e) { t1_pass = false; resultsText += `   ❌ FAIL: ${e.message}\n\n`; }
            if (!t1_pass) allPass = false;

            resultsText += 'T2: УНИКАЛЬНОСТЬ (200 HUIDs)\n';
            const t2_hashes = new Set();
            const N = 200;
            let t2_pass = true;
            try {
                 for (let i = 0; i < N; i++) {
                    const sig = await generateSignature({ ...t1_inputs, huid: `TEST-UNIQUE-${i}`, style: 'geometric' });
                    t2_hashes.add(sig.hashHex);
                     if (i % 20 === 19) {
                        resultsDiv.textContent = resultsText + `   Прогресс: ${i + 1}/${N}...`;
                        await new Promise(r => setTimeout(r, 0));
                    }
                }
                if (t2_hashes.size !== N) t2_pass = false;
                resultsText += `   Уникальных хешей: ${t2_hashes.size}/${N}\n`;
                resultsText += `   Результат: ${t2_pass ? '✅ PASS' : '❌ FAIL'}\n\n`;
            } catch (e) { t2_pass = false; resultsText += `   ❌ FAIL: ${e.message}\n\n`; }
            if (!t2_pass) allPass = false;
            
            resultsText += 'T3: РАЗЛИЧИЕ СТИЛЕЙ (SVG-хэши)\n';
            let t3_pass = true;
            try {
                const t3_inputs = { ...t1_inputs, huid: 'TEST-STYLES-V11' };
                const sigOrganica = await generateSignature({ ...t3_inputs, style: 'organica' });
                const sigGeometric = await generateSignature({ ...t3_inputs, style: 'geometric' });
                const hashOrganica = await sha256Hex(sigOrganica.svgContent);
                const hashGeometric = await sha256Hex(sigGeometric.svgContent);

                if (hashOrganica === hashGeometric) t3_pass = false;
                resultsText += `   Hash Organica:  ${hashOrganica.substring(0, 24)}...\n`;
                resultsText += `   Hash Geometric: ${hashGeometric.substring(0, 24)}...\n`;
                resultsText += `   Результат: ${t3_pass ? '✅ PASS' : '❌ FAIL (хэши совпали)'}\n\n`;
            } catch (e) { t3_pass = false; resultsText += `   ❌ FAIL: ${e.message}\n\n`; }
            if (!t3_pass) allPass = false;

            resultsText += '='.repeat(40) + '\n';
            resultsText += `ОБЩИЙ РЕЗУЛЬТАТ: ${allPass ? '✅ ALL TESTS PASSED' : '❌ SOME TESTS FAILED'}\n`;
            resultsDiv.textContent = resultsText;
            showStatus(allPass ? 'Все тесты пройдены!' : '⚠️ Некоторые тесты не пройдены', allPass ? 'success' : 'error');
        }
        
        async function validateFromJSON() {
            if (!jsonFileContent) {
                showStatus('Сначала загрузите JSON файл.', 'error'); return;
            }
            const resultsDiv = $('validationResults');
            resultsDiv.textContent = 'Валидация файла...\n\n';
            showStatus('Валидация...', 'info');

            try {
                const { hashHex: originalHash, ...dataToRehash } = jsonFileContent;
                if (!originalHash || !dataToRehash.inputs || !dataToRehash.seedHex) {
                    throw new Error("Неверный формат JSON: отсутствуют обязательные поля.");
                }

                const recalculatedSeed = await sha256Hex(makeSeedString(dataToRehash.inputs));
                const seedMatch = dataToRehash.seedHex === recalculatedSeed;
                const canonicalData = canonicalJSON(dataToRehash);
                const recalculatedHash = await sha256Hex(JSON.stringify(canonicalData));
                const hashMatch = originalHash === recalculatedHash;

                let resultsText = `🔍 РЕЗУЛЬТАТЫ ВАЛИДАЦИИ\n` + '='.repeat(40) + '\n\n';
                resultsText += `Seed совпадает: ${seedMatch ? '✅ ДА' : '❌ НЕТ'}\n`;
                resultsText += ` - Оригинал: ${dataToRehash.seedHex.substring(0,32)}...\n`;
                resultsText += ` - Пересчет:  ${recalculatedSeed.substring(0,32)}...\n\n`;
                resultsText += `Контент-хэш совпадает: ${hashMatch ? '✅ ДА' : '❌ НЕТ'}\n`;
                resultsText += ` - Оригинал: ${originalHash.substring(0,32)}...\n`;
                resultsText += ` - Пересчет:  ${recalculatedHash.substring(0,32)}...\n\n`;
                resultsText += `🏁 ВЕРДИКТ: ${seedMatch && hashMatch ? '✅ ВАЛИДАЦИЯ ПРОЙДЕНА' : '❌ ВАЛИДАЦИЯ НЕ ПРОЙДЕНА'}\n`;

                resultsDiv.textContent = resultsText;
                showStatus(seedMatch && hashMatch ? '✅ Валидация успешна' : '❌ Валидация не пройдена', seedMatch && hashMatch ? 'success' : 'error');

            } catch(error) {
                console.error("Ошибка валидации:", error);
                resultsDiv.textContent = `❌ Ошибка валидации: ${error.message}`;
                showStatus(`Ошибка валидации: ${error.message}`, 'error');
            }
        }

        function showStatus(message, type) {
            const el = $('statusInfo');
            el.textContent = message;
            el.className = `status-info status-${type}`;
            el.style.display = 'block';
            setTimeout(() => {
                if (el.textContent === message) el.style.display = 'none';
            }, 4000);
        }

        function updateSliderValue(sliderId, displayId) {
            const slider = $(sliderId);
            const display = $(displayId);
            if (slider && display) display.textContent = slider.value;
        }

        document.addEventListener('DOMContentLoaded', () => {
            $('timestamp').value = Date.now();

            $('generateButton').addEventListener('click', handleGenerateClick);
            $('runTestsButton').addEventListener('click', runTests);
            $('validateJSONButton').addEventListener('click', validateFromJSON);

            $('exportPNGButton').addEventListener('click', exportPNG);
            $('exportSVGButton').addEventListener('click', () => exportFile(`signature-${currentSignatureData?.inputs?.huid}.svg`, currentSignatureData?.svgContent || '', 'image/svg+xml;charset=utf-8'));
            $('exportJSONButton').addEventListener('click', () => {
                if (!currentSignatureData) { showStatus('Сначала сгенерируйте подпись', 'error'); return; }
                const { svgContent, ...jsonData } = currentSignatureData;
                exportFile(`signature-${jsonData.inputs.huid}.json`, JSON.stringify(canonicalJSON(jsonData), null, 2), 'application/json')
            });
            
            $('jsonFile').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            jsonFileContent = JSON.parse(e.target.result);
                            showStatus(`Файл ${file.name} загружен`, 'success');
                            $('validationResults').textContent = `Файл ${file.name} готов к валидации.`;
                        } catch (error) {
                            jsonFileContent = null;
                            showStatus('Ошибка парсинга JSON', 'error');
                            $('validationResults').textContent = `Ошибка чтения файла: ${error.message}`;
                        }
                    };
                    reader.readAsText(file);
                }
            });

            ['lineScale', 'wavesIntensity', 'pointsDensity', 'raysLevel', 'penMul', 'penSmooth'].forEach(id => {
                $(id).addEventListener('input', () => updateSliderValue(id, id + 'Value'));
            });

            $('style').addEventListener('change', (e) => {
                $('calligraphicParams').style.display = e.target.value === 'calligraphic' ? 'block' : 'none';
            });

            handleGenerateClick();
        });
    </script>
</body>
</html>
