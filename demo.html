<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Генератор Энергоподписей — demo</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,system-ui,Arial,sans-serif;background:#f5f7fa;color:#222;min-height:100vh;padding:20px;line-height:1.6}
    .container{max-width:1200px;margin:0 auto;background:#fff;border-radius:12px;padding:28px;border:1px solid #e6eaf0;box-shadow:0 2px 10px rgba(0,0,0,.05)}
    h1{font-size:28px;font-weight:700;color:#1f2a44;margin-bottom:8px}
    .sub{color:#5f6b7a;margin-bottom:24px}
    .main{display:grid;grid-template-columns:1fr 1fr;gap:24px}
    .form{display:flex;flex-direction:column;gap:16px}
    .group{display:flex;flex-direction:column;gap:8px}
    label{font-weight:600;color:#2a3b55}
    input,select{border:1px solid #d6dde7;border-radius:8px;padding:10px 12px;font-size:14px}
    .grid4{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
    .btn{appearance:none;border:none;border-radius:10px;background:#3a7afe;color:#fff;padding:12px 16px;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(.95)}
    .btn.secondary{background:#95a5a6}
    .btn.success{background:#27ae60}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    #canvas{width:512px;height:512px;display:flex;align-items:center;justify-content:center;border:2px solid #ecf0f1;border-radius:12px;background:#fff}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;font-size:13px;white-space:pre-wrap}
    .panel{padding:12px;border:1px solid #e6eaf0;border-radius:10px;background:#f9fbff}
    .ok{background:#e8f7ee;border-color:#b7e3c4;color:#1e7e34}
    .err{background:#feefef;border-color:#ffc4c4;color:#c0392b}
    .inf{background:#e9f3ff;border-color:#cfe2ff;color:#2255b5}
    @media(max-width:900px){.main{grid-template-columns:1fr} #canvas{width:100%;height:auto;aspect-ratio:1/1}}
  </style>
</head>
<body>
<div class="container">
  <h1>Генератор Энергоподписей <span style="font-weight:400">/ demo</span></h1>
  <div class="sub">Ветка рендера по стилю: <b>organica</b> (плавные кривые) и <b>geometric</b> (полигоны/суперэллипс + лучи). Канонический JSON (рекурсивная сортировка) и корректные тесты T1–T3.</div>

  <div class="main">
    <div class="form">
      <div class="group">
        <label for="huid">HUID</label>
        <input id="huid" value="user_12345">
      </div>
      <div class="group">
        <label for="timestamp">Timestamp (UTC ms)</label>
        <input id="timestamp" type="number">
      </div>
      <div class="group">
        <label>Энергии [P, I, E, C] (0–5)</label>
        <div class="grid4">
          <input id="e0" type="number" min="0" max="5" step="1" value="3" placeholder="P">
          <input id="e1" type="number" min="0" max="5" step="1" value="4" placeholder="I">
          <input id="e2" type="number" min="0" max="5" step="1" value="2" placeholder="E">
          <input id="e3" type="number" min="0" max="5" step="1" value="5" placeholder="C">
        </div>
      </div>
      <div class="group">
        <label for="style">Стиль</label>
        <select id="style">
          <option value="organica">organica</option>
          <option value="geometric">geometric</option>
        </select>
      </div>
      <div class="group">
        <label for="context">Контекст</label>
        <input id="context" value="test_context">
      </div>
      <div class="row">
        <button class="btn" onclick="generate()">Сгенерировать</button>
        <button class="btn secondary" onclick="exportSVG()">Экспорт SVG</button>
        <button class="btn secondary" onclick="exportPNG()">Экспорт PNG</button>
        <button class="btn success" onclick="exportJSON()">Экспорт JSON</button>
      </div>

      <div class="panel" id="status" style="display:none"></div>

      <div class="group">
        <h3 style="margin-top:8px;margin-bottom:6px">Тесты</h3>
        <div class="row">
          <button class="btn secondary" onclick="runTests()">Запустить T1–T3</button>
        </div>
        <div id="tests" class="mono panel" style="margin-top:8px;max-height:220px;overflow:auto"></div>
      </div>

      <div class="group">
        <h3 style="margin-top:8px;margin-bottom:6px">Валидатор JSON</h3>
        <input type="file" id="jsonFile" accept=".json">
        <div class="row">
          <button class="btn success" onclick="validateFromFile()">Валидировать</button>
        </div>
        <div id="validation" class="mono panel" style="margin-top:8px"></div>
      </div>
    </div>

    <div>
      <div id="canvas">
        <div style="color:#97a3b6">SVG 512×512 появится здесь</div>
      </div>
    </div>
  </div>
</div>

<script>
// ---------- утилиты ----------
const hex = b => [...new Uint8Array(b)].map(x => x.toString(16).padStart(2,'0')).join('');
const sha256Hex = async (s) => hex(await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)));
const u32 = (h,o) => parseInt(h.slice(o,o+8),16)>>>0;
const clampE = v => Math.max(0, Math.min(5, parseInt(v)||0));

// sfc32 PRNG
const sfc32 = (a,b,c,d)=>function(){a|=0;b|=0;c|=0;d|=0;let t=(a+b|0)+d|0;d=d+1|0;a=b^(b>>>9);b=c+(c<<3)|0;c=(c<<21)|(c>>>11);c=c+t|0;return (t>>>0)/4294967296;};

class PRNG{
  constructor(seedHex){ this.rng = sfc32(u32(seedHex,0),u32(seedHex,8),u32(seedHex,16),u32(seedHex,24)); }
  next(){ return this.rng(); }
  int(min,max){ return Math.floor(this.next()*(max-min+1))+min; }
  float(min,max){ return this.next()*(max-min)+min; }
}

// deep canonical JSON
function canonicalizeDeep(value){
  if (Array.isArray(value)) return value.map(canonicalizeDeep);
  if (value && typeof value==='object'){
    const out = {};
    Object.keys(value).sort().forEach(k => { out[k] = canonicalizeDeep(value[k]); });
    return out;
  }
  return value;
}
function canonicalStringifyDeep(obj){ return JSON.stringify(canonicalizeDeep(obj)); }

// цветоведение (сдержанные тона)
function hsla(h,s,l,a=1){ s=Math.max(0,Math.min(100,s)); l=Math.max(0,Math.min(100,l)); return `hsla(${Math.round(h)%360}, ${s}%, ${l}%, ${a})`; }
function colorFromEnergy(e, prng, opts={}){
  // базовый тон — избегаем "конфетности": ограничим сатурацию и светлоту
  const hue = (e*137.5 + prng.float(-10,10))%360;
  const s = Math.min(60, 40 + prng.float(0,20)); // <=60%
  const l = Math.min(65, 35 + prng.float(0,25)); // умеренно
  const a = opts.alpha ?? 1;
  return hsla(hue, s, l, a);
}
function subtleDotColor(e, prng, a=0.3){
  const hue = (e*137.5 + prng.float(-15,15))%360;
  const s = 10 + prng.float(0,15); // низкая насыщенность
  const l = 55 + prng.float(0,10);
  return hsla(hue, s, l, a);
}

async function makeSeed(huid, ts, energies, context, style){
  const seedString = `${huid}|${ts}|${energies.join(',')}|${context}|${style}|v12`;
  return await sha256Hex(seedString);
}

// ---------- слои ----------

// 1) поле/волны (разные для стилей)
function layerField(energies, prng, style, size=512){
  const defsId = 'grad'+Math.floor(prng.float(1,1e9));
  const c1 = colorFromEnergy(energies[1], prng);
  const c2 = colorFromEnergy(energies[2], prng);
  let svg = `
    <defs>
      <linearGradient id="${defsId}" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:${c1};stop-opacity:1"/>
        <stop offset="100%" style="stop-color:${c2};stop-opacity:1"/>
      </linearGradient>
    </defs>`;
  const cx=size/2, cy=size/2;

  if (style==='organica'){
    // плавные синусные/катмулл-ром кривые
    const count = prng.int(3,6);
    for (let i=0;i<count;i++){
      const amp = prng.float(18,90);
      const freq = prng.float(0.012,0.05);
      const phase = prng.float(0,Math.PI*2);
      const thick = prng.float(1,3);
      let d = `M 0 ${cy + amp*Math.sin(phase)}`;
      for (let x=0;x<=size;x+=2){
        const y = cy + amp*Math.sin(x*freq + phase + i*0.6);
        d += ` L ${x} ${y}`;
      }
      svg += `<path d="${d}" stroke="url(#${defsId})" stroke-width="${thick}" fill="none" opacity="0.7"/>`;
    }
  }else{
    // geometric: концентрические многоугольники
    const rings = prng.int(3,6);
    const sides = (Math.floor(energies[0])%8)+4;
    for (let r=0;r<rings;r++){
      const rad = 80 + r*35 + prng.float(-8,8);
      const thick = prng.float(0.8,2.2);
      let d="";
      for (let i=0;i<sides;i++){
        const a = (i/sides)*Math.PI*2 - Math.PI/2;
        const x = cx + rad*Math.cos(a);
        const y = cy + rad*Math.sin(a);
        d += (i===0?`M ${x} ${y}`:` L ${x} ${y}`);
      }
      d += " Z";
      svg += `<path d="${d}" fill="none" stroke="url(#${defsId})" stroke-width="${thick}" opacity="0.7"/>`;
    }
  }
  return {svg, meta:{type:style==='organica'?'waves':'rings'}};
}

// 2) центральная эмблема (реальное ветвление стилей)
function superformulaPoint(a,b,m,n1,n2,n3,phi){
  // r = (|cos(m*phi/4)/a|^n2 + |sin(m*phi/4)/b|^n3)^(-1/n1)
  const t1 = Math.pow(Math.abs(Math.cos(m*phi/4)/a), n2);
  const t2 = Math.pow(Math.abs(Math.sin(m*phi/4)/b), n3);
  const r = Math.pow(t1+t2, -1/Math.max(0.0001,n1));
  return {r};
}
function organicaGlyph(energies, prng, size=512){
  const cx=size/2, cy=size/2;
  // параметры суперформулы из энергий + PRNG
  const a=1, b=1;
  const m = prng.int(4,12) + energies[0];
  const n1 = 0.2 + (energies[1]*0.35) + prng.float(0,0.6);
  const n2 = 0.2 + (energies[2]*0.4)  + prng.float(0,0.6);
  const n3 = 0.2 + (energies[3]*0.4)  + prng.float(0,0.6);
  const R = prng.float(70,110);
  const steps = 360;
  let d="";
  for (let i=0;i<=steps;i++){
    const phi = (i/steps)*Math.PI*2;
    const {r} = superformulaPoint(a,b,m,n1,n2,n3,phi);
    const x = cx + R*r*Math.cos(phi);
    const y = cy + R*r*Math.sin(phi);
    d += (i===0?`M ${x} ${y}`:` L ${x} ${y}`);
  }
  const fill = colorFromEnergy(energies[3], prng, {alpha:0.85});
  const stroke = colorFromEnergy(energies[0], prng);
  const path = `<path d="${d} Z" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
  return {svg:path, meta:{style:'organica', m, n1:+n1.toFixed(2), n2:+n2.toFixed(2), n3:+n3.toFixed(2), radius:Math.round(R)}};
}

function superellipsePoint(a,b,n,t){
  const ct = Math.cos(t), st = Math.sin(t);
  const x = Math.sign(ct) * Math.pow(Math.abs(ct), 2/n) * a;
  const y = Math.sign(st) * Math.pow(Math.abs(st), 2/n) * b;
  return {x,y};
}
function geometricGlyph(energies, prng, size=512){
  const cx=size/2, cy=size/2;
  const a = prng.float(60,100);
  const b = prng.float(60,100);
  const n = 2 + energies[0] + prng.float(0,1.5); // степень суперэллипса
  const steps = 180;
  let d="";
  for (let i=0;i<=steps;i++){
    const t = (i/steps)*Math.PI*2;
    const {x,y} = superellipsePoint(a,b,n,t);
    d += (i===0?`M ${cx+x} ${cy+y}`:` L ${cx+x} ${cy+y}`);
  }
  d += " Z";

  // лучи
  const rays = (energies[2] % 5) + 6 + prng.int(0,4);
  let raysSvg = "";
  for (let i=0;i<rays;i++){
    const ang = (i/rays)*Math.PI*2 + prng.float(-0.05,0.05);
    const r1 = prng.float(20,40);
    const r2 = prng.float(110,150);
    const x1 = cx + r1*Math.cos(ang);
    const y1 = cy + r1*Math.sin(ang);
    const x2 = cx + r2*Math.cos(ang);
    const y2 = cy + r2*Math.sin(ang);
    raysSvg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${colorFromEnergy(energies[1], prng)}" stroke-width="${prng.float(0.7,1.8)}" opacity="0.6"/>`
  }

  const fill = colorFromEnergy(energies[3], prng, {alpha:0.8});
  const stroke = colorFromEnergy(energies[0], prng);
  const path = `<path d="${d}" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
  return {svg:raysSvg + path, meta:{style:'geometric', a:Math.round(a), b:Math.round(b), n:+n.toFixed(2), rays}};
}

function layerGlyph(energies, prng, style, size=512){
  return (style==='organica') ? organicaGlyph(energies, prng, size)
                              : geometricGlyph(energies, prng, size);
}

// 3) защитные точки (ТРЕТИЙ слой сверху, приглушённые)
function layerDefensiveDots(energies, prng, size=512){
  const count = prng.int(180,400);
  let svg="";
  let sumR=0;
  for (let i=0;i<count;i++){
    const x = prng.float(8,size-8);
    const y = prng.float(8,size-8);
    const r = prng.float(0.8,3.2);
    sumR += r;
    const c = subtleDotColor(energies[i%4], prng, 0.28);
    svg += `<circle cx="${x}" cy="${y}" r="${r}" fill="${c}" />`;
  }
  return {svg, meta:{points:count, avgSize:+(sumR/count).toFixed(2)}};
}

// полный SVG
function buildSVG(layersSvg){
  return `<svg width="512" height="512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">${layersSvg}</svg>`;
}

// ---------- основная генерация ----------
let current = null;

async function generate(){
  const huid = document.getElementById('huid').value.trim();
  const ts = parseInt(document.getElementById('timestamp').value || Date.now());
  const energies = [clampE(e0.value), clampE(e1.value), clampE(e2.value), clampE(e3.value)];
  const context = document.getElementById('context').value.trim();
  const style = document.getElementById('style').value;

  if (!huid || !Number.isFinite(ts) || energies.some(e=>Number.isNaN(e)) || !context){ return setStatus('Заполните все поля', 'err'); }

  setStatus('Генерация...', 'inf');
  const t0 = performance.now();

  const seedHex = await makeSeed(huid, ts, energies, context, style);
  const prng = new PRNG(seedHex);

  const field = layerField(energies, prng, style);
  const glyph = layerGlyph(energies, prng, style);
  const dots  = layerDefensiveDots(energies, prng, style);

  const svg = buildSVG(`${field.svg}${glyph.svg}${dots.svg}`);

  document.getElementById('canvas').innerHTML = svg;

  const jsonBare = {
    seedHex,
    inputs: { huid, ts, energies, context, style },
    layers: { field: field.meta, glyph: glyph.meta, defensiveDots: dots.meta },
    metadata: { generatedAt: new Date().toISOString(), version: "v12", generationTime: Math.round(performance.now()-t0) }
  };

  // канонический JSON РЕКУРСИВНО (без hashHex)
  const canonical = canonicalStringifyDeep(jsonBare);
  const hashHex = await sha256Hex(canonical);

  current = { ...jsonBare, hashHex, svg };

  setStatus(`Готово за ${current.metadata.generationTime}мс`, 'ok');
}

// ---------- экспорт ----------
function downloadFile(name, content, type){
  const blob = new Blob([content], {type});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

function exportSVG(){
  if (!current) return setStatus('Сначала сгенерируйте', 'err');
  downloadFile(`energy-${current.inputs.huid}.svg`, current.svg, 'image/svg+xml');
}
function exportJSON(){
  if (!current) return setStatus('Сначала сгенерируйте', 'err');
  const out = { seedHex: current.seedHex, hashHex: current.hashHex, inputs: current.inputs, layers: current.layers, metadata: current.metadata };
  downloadFile(`energy-${current.inputs.huid}.json`, JSON.stringify(out, null, 2), 'application/json');
}
function exportPNG(){
  if (!current) return setStatus('Сначала сгенерируйте', 'err');
  const img = new Image();
  const url = URL.createObjectURL(new Blob([current.svg], {type:'image/svg+xml'}));
  img.onload = ()=>{
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);
    canvas.toBlob(b=>downloadFile(`energy-${current.inputs.huid}.png`, b, 'image/png'));
  };
  img.src = url;
}

// ---------- тесты ----------
async function runTests(){
  const out = [];
  try{
    out.push("РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ\n");

    // T1: детерминизм — полное SVG 512×512
    const base = {huid:'TEST-DET', ts:1640995200000, energies:[1,2,3,4], context:'test'};
    const style='organica';
    const svgHashes=[];
    for (let i=0;i<3;i++){
      const seedHex = await makeSeed(base.huid, base.ts, base.energies, base.context, style);
      const prng = new PRNG(seedHex);
      const s1 = layerField(base.energies, prng, style).svg;
      const s2 = layerGlyph(base.energies, prng, style).svg;
      const s3 = layerDefensiveDots(base.energies, prng, style).svg;
      const svg = buildSVG(`${s1}${s2}${s3}`);
      svgHashes.push(await sha256Hex(svg));
    }
    const t1 = (svgHashes[0]===svgHashes[1] && svgHashes[1]===svgHashes[2]);
    out.push(`T1 Детерминизм: ${t1?'PASS':'FAIL'}  hash=${svgHashes[0]}`);

    // T2: уникальность — 10 разных HUID
    const set = new Set();
    for (let i=0;i<10;i++){
      const seedHex = await makeSeed(`TEST-${i}`, base.ts, base.energies, base.context, 'organica');
      const bare = {seedHex, inputs:{huid:`TEST-${i}`, ts:base.ts, energies:base.energies, context:base.context, style:'organica'}, layers:{}, metadata:{version:'v12'}};
      const canon = canonicalStringifyDeep(bare); // глубокая сортировка
      set.add(await sha256Hex(canon));
    }
    const t2 = set.size===10;
    out.push(`T2 Уникальность(10 HUID): ${t2?'PASS':'FAIL'}  уникальных=${set.size}/10`);

    // T3: рендер-стили — SHA-256(SVG) для organica vs geometric
    const base2 = {huid:'TEST-STYLE', ts:1640995200000, energies:[2,3,4,5], context:'test'};
    const seedOrg = await makeSeed(base2.huid, base2.ts, base2.energies, base2.context, 'organica');
    const prOrg = new PRNG(seedOrg);
    const svgOrg = buildSVG(layerField(base2.energies, prOrg, 'organica').svg + layerGlyph(base2.energies, prOrg, 'organica').svg + layerDefensiveDots(base2.energies, prOrg, 'organica').svg);
    const hOrg = await sha256Hex(svgOrg);

    const seedGeo = await makeSeed(base2.huid, base2.ts, base2.energies, base2.context, 'geometric');
    const prGeo = new PRNG(seedGeo);
    const svgGeo = buildSVG(layerField(base2.energies, prGeo, 'geometric').svg + layerGlyph(base2.energies, prGeo, 'geometric').svg + layerDefensiveDots(base2.energies, prGeo, 'geometric').svg);
    const hGeo = await sha256Hex(svgGeo);

    const t3 = (hOrg !== hGeo);
    out.push(`T3 Стили (SHA-256(SVG)): ${t3?'PASS':'FAIL'}\n  organica: ${hOrg}\n  geometric: ${hGeo}`);

    const all = t1 && t2 && t3;
    out.push(`\nИТОГО: ${all?'ALL TESTS PASSED ✅':'SOME TESTS FAILED ❌'}`);
  }catch(err){
    out.push("Ошибка тестов: "+err.message);
  }
  document.getElementById('tests').textContent = out.join('\n');
  setStatus('Тесты выполнены', 'ok');
}

// ---------- валидатор ----------
async function validateFromFile(){
  const f = document.getElementById('jsonFile').files[0];
  if (!f) return setStatus('Выберите JSON', 'err');
  try{
    const txt = await f.text();
    const data = JSON.parse(txt);
    const {seedHex, hashHex, inputs} = data;
    // пересчитать seed
    const reSeed = await makeSeed(inputs.huid, inputs.ts, inputs.energies, inputs.context, inputs.style);
    // пересчитать hashHex от канонического JSON БЕЗ hashHex
    const copy = JSON.parse(JSON.stringify(data));
    delete copy.hashHex;
    const canon = canonicalStringifyDeep(copy);
    const reHash = await sha256Hex(canon);

    const okSeed = (reSeed===seedHex);
    const okHash = (reHash===hashHex);

    document.getElementById('validation').textContent =
`Валидация JSON:
 seedHex  : ${okSeed?'OK':'MISMATCH'}
  - исходный: ${seedHex}
  - пересчет: ${reSeed}
 hashHex  : ${okHash?'OK':'MISMATCH'}
  - исходный: ${hashHex}
  - пересчет: ${reHash}
 Итог     : ${okSeed && okHash ? 'PASS' : 'FAIL'}`;
    setStatus(okSeed && okHash ? 'Валидация пройдена' : 'Валидация не пройдена', okSeed&&okHash?'ok':'err');
  }catch(e){
    setStatus('Ошибка валидации: '+e.message, 'err');
  }
}

// ---------- служебные ----------
function setStatus(msg, kind){
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'panel ' + (kind==='ok'?'ok':kind==='err'?'err':'inf');
  el.style.display='block';
  if (kind!=='err'){ setTimeout(()=>el.style.display='none',2500); }
}

// headless режим совместим с исходным ТЗ (?auto=1&fmt=json|svg|png)
async function headless(){
  const p = new URLSearchParams(location.search);
  if (p.get('auto')!=='1') return;
  const fmt = p.get('fmt')||'json';
  // скрыть интерфейс
  document.body.style.display='none';

  // заполнить параметры по умолчанию
  document.getElementById('timestamp').value = Date.now();
  await generate();

  if (!current){ document.body.innerHTML = '<pre>error</pre>'; document.body.style.display='block'; return; }

  if (fmt==='json'){
    const out = { seedHex: current.seedHex, hashHex: current.hashHex, inputs: current.inputs, layers: current.layers, metadata: current.metadata };
    document.body.innerHTML = `<pre class="mono">${JSON.stringify(out,null,2)}</pre>`;
  } else if (fmt==='svg'){
    document.body.innerText = current.svg;
  } else if (fmt==='png'){
    // минимальная реализация: отдаём dataURL
    const img = new Image();
    const url = URL.createObjectURL(new Blob([current.svg], {type:'image/svg+xml'}));
    img.onload = ()=>{
      const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=512;
      const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0); URL.revokeObjectURL(url);
      document.body.innerText = canvas.toDataURL('image/png');
    };
    img.src = url;
  }
  document.body.style.display='block';
}

document.addEventListener('DOMContentLoaded', ()=>{
  document.getElementById('timestamp').value = Date.now();
  headless();
});
</script>
</body>
</html>
